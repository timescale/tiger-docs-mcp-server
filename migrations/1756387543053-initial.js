import 'dotenv/config';
import { Client } from 'pg';

const schema = process.env.DB_SCHEMA;
if (!schema) {
  throw new Error('DB_SCHEMA is not defined');
}

export const description = 'Create schema and memory table';

export async function up() {
  const client = new Client();

  try {
    await client.connect();
    await client.query('BEGIN');
    await client.query(/* sql */ `
      CREATE EXTENSION IF NOT EXISTS vector;

      CREATE TABLE IF NOT EXISTS ${schema}.postgres(
        id int8 NOT NULL PRIMARY KEY generated by default as identity
        , version int2 NOT NULL
        , header text NOT NULL
        , header_path text[] NOT NULL
        , header_depth int4 NOT NULL
        , content text NOT NULL
        , token_count int8 NOT NULL
        , embedding vector(1536)
      );

      CREATE TABLE ${schema}.timescale_pages (
        id int4 PRIMARY KEY generated by default as identity
        , url TEXT UNIQUE NOT NULL
        , domain TEXT NOT NULL
        , filename TEXT NOT NULL
        , content_length INTEGER
        , scraped_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        , chunking_method TEXT DEFAULT 'header'
        , chunks_count INTEGER DEFAULT 0
      );

      CREATE TABLE IF NOT EXISTS ${schema}.timescale_chunks (
        id int4 PRIMARY KEY generated by default as identity
        , page_id INTEGER REFERENCES ${schema}.timescale_pages(id) ON DELETE CASCADE
        , chunk_index INTEGER NOT NULL
        , sub_chunk_index INTEGER NOT NULL DEFAULT 0
        , content TEXT NOT NULL
        , metadata JSONB
        , embedding vector(1536)
        , created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
    `);
    await client.query('COMMIT');
  } catch (e) {
    await client.query('ROLLBACK');
    throw e;
  } finally {
    await client.end();
  }
}

export async function down() {
  const client = new Client();

  try {
    await client.connect();
    await client.query(/* sql */ `
      DROP INDEX IF EXISTS ${schema}.idx_memory_key;
      DROP TABLE IF EXISTS ${schema}.memory
      `);
  } finally {
    await client.end();
  }
}
